#!/usr/bin/python
# -*- coding: UTF-8 -*-

"""
This is a phonelog GTK+ GUI, designed to use with a custom daemon,
the SHR daemon, and when ready, opimd.

Written by Tom Hacohen. (tom@stosb.com), 
contributions from Sebastian Spaeth (Sebastian@SSpaeth.de)

Licensed by GPLv2
"""

__version__ = "0.16.1"


import time, ConfigParser
import os.path
import shutil
import re
from datetime import datetime

import dbus
import gobject, gtk
import sqlite3
from dbus.mainloop.glib import DBusGMainLoop

try:
	import mokoui
	use_mokoui = True
except:
	use_mokoui = False


#constants
CONFIGURATION_DIR = os.path.join(os.path.expanduser('~'), '.phonelog')
TIME_FILE = CONFIGURATION_DIR + "time.dat"
CONFIGURATION_FILE = os.path.join(CONFIGURATION_DIR,'phonelog.conf')
DEFAULT_CONFIG_PATH = "/usr/share/phonelog/skeleton/phonelog.conf"
ICONS_PATH = "/usr/share/phonelog/icons/"

#PAGES POSITIONS
PAGE_INCOMING = 0 
PAGE_OUTGOING = 1
PAGE_MISSED = 2
PAGE_GENERAL = 3
PAGE_SETTINGS = 4

class CallsTab:
	#POSITION IN MODEL
	CONTACT_POSITION = 0
	NUMBER_POSITION = 1
	DATE_POSITION = 2
	DURATION_POSITION = 3
	VISUAL_POSITION = 4
	STATUS_POSITION = 5
	
	#ACTUAL GUI POSTITON
	CONTACT_COLUMN = 0
	DATE_COLUMN = 1
	__list = None
	__contact_show_column = CONTACT_POSITION
	__date_show_column = DATE_POSITION
	__tab = None
	__type = None
	__mark_new = False
        conf = None #inited with ConfigParser object once!
	
	def __init__(self, type, mark_new = False, conf=None):
                # init the ConfigParser object once, bail out if failing.
                if CallsTab.conf == None:
                  CallsTab.conf = conf
                assert CallsTab.conf != None
		self.createList()
		self.__type = type
		self.__createCallsTab()
		self.last_refresh = CallsTab.conf.getfloat('viewlog',self.__type)
		self.__mark_new = mark_new
	def getList(self):
		return self.__list

	def getTab(self):
		return self.__tab
	def shouldMarkNew(self):
		return self.__mark_new
	def __getContactColumn(self):
		return self.CONTACT_COLUMN
	def __getDateColumn(self):
		return self.DATE_COLUMN

	def __createCallsTab(self):
		page = gtk.VBox()
		page.pack_start( self.__initScrolled() )
		align = gtk.Alignment(1,1,1,1)
		
		buttons = gtk.HBox(homogeneous=True)
		align.add(buttons)
		page.pack_start(align, False, padding = 3)

		buttons_height = CallsTab.conf.getint('phonelog','buttons_height')
		
		callButton = gtk.Button("Call")
		callButton.connect ("clicked", self.callButton_clicked)
		callButton.set_size_request(-1,buttons_height)

		numberButton = gtk.Button("Numbers")
		numberButton.connect ("clicked", self.numberButton_clicked)
		numberButton.set_size_request(-1,buttons_height)

		durationButton = gtk.Button("Duration")
		durationButton.connect ("clicked", self.durationButton_clicked)
		durationButton.set_size_request(-1,buttons_height)
		
		buttons.pack_start(callButton, True, padding = 1)
		buttons.pack_start(numberButton, True, padding = 3)
		buttons.pack_start(durationButton, True, padding = 1)
		
		self.__tab = page
	def __createTreeView(self):
		self.__list = gtk.TreeView (gtk.TreeStore( gobject.TYPE_STRING, 
					gobject.TYPE_STRING,
					gobject.TYPE_STRING,
					gobject.TYPE_STRING,
					gobject.TYPE_BOOLEAN,  #the boolean is there for coloring
					gobject.TYPE_STRING ) #should be changed to an icon?
					)
		self.__list.set_property('headers-visible', CallsTab.conf.getboolean('phonelog','lists_headers_visible'))
	def createList(self):

		self.__createTreeView()

		renderer = gtk.CellRendererText()
		#change text size as well?
		#renderer.set_property('weight', 800)
		renderer.set_property('foreground', 'red')

		contact_column = gtk.TreeViewColumn("Contact", renderer, text=self.CONTACT_POSITION, foreground_set=self.VISUAL_POSITION)
		self.__list.insert_column( contact_column, self.__getContactColumn() )
		time_column = gtk.TreeViewColumn("Time", renderer, text=self.DATE_POSITION, foreground_set=self.VISUAL_POSITION)
		self.__list.insert_column( time_column, self.__getDateColumn())
		
	def __initScrolled(self):
		tab_content = self.__list
		if use_mokoui:
			scrolled = mokoui.FingerScroll()
		else:
			scrolled = gtk.ScrolledWindow()
			scrolled.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

		scrolled.add_with_viewport(tab_content)
		return scrolled
		
	def __getCalls(self):
		global phone_data
		type = self.__type
		calls = phone_data.getCalls(type)
		return calls
	def populateList(self, group_type = 1):
		"""
		group_type =
		0 - never group
		1/everything else - always group
		2 - group from the same type only.
		"""
		global phone_data
		
		list = self.__list
		type = self.__type
		previous_time = datetime.fromtimestamp(CallsTab.conf.getfloat('viewlog', type))
		visual_flag = self.shouldMarkNew()

		calls = self.__getCalls()
		if calls == None:
			return False
			
		#get and clear the model.
		model = list.get_model()
		model.clear()

		
		last_parent_added = None
		child_count = 0
		
		for call in calls:
			
			number = call[0]
			contact = phone_data.getContact(number)
			timestamp = float(call[1])	
			call_time = datetime.fromtimestamp( timestamp )
			status = call[2]

			if CallsTab.conf.getboolean('phonelog','phonekitd'):
				active_time = call[3]

				#untill the change will be coded in the daemon
				if active_time == None:
					active_time = "00:00"
			else:
				active_time = "No legacy support"

			#hack because of the (frameworks?) double quotes bug
			number = number.strip('"')
			
			#HACK FOR THE GENERAL LIST
			if CallsTab.conf.getboolean('phonelog','phonekitd'):
				if active_time == "00:00":
					status += 2
					#Usually it shouldn't be changed back, things have
					#to change before that can happen
					if status == 3:
						status = 1

			missed = (status == 2)

			#don't group supressed numbers
			#and make the contact Unknown Number
			if number == "*****":
				last_parent_added = None
				contact = CallsTab.conf.get('phonelog',"suppressed_name")

				
			#check if should be grouped
			#if grouping should stop, update the child count to the father
			parent = None
			if last_parent_added != None:
				#also counts the father as a child
				child_count += 1 
				
				if (((last_contact == contact) and (contact != "")) \
						or (last_number == number))\
					and (last_status == status):		
					parent = last_parent_added
				else:
					if child_count > 1:
						#if set in config, add the '(count)' to the contact field
						if CallsTab.conf.getboolean('phonelog','show_group_count'):
							current_value = model[last_parent_added][self.CONTACT_POSITION]
							model.set_value(last_parent_added,self.CONTACT_POSITION, "%s (%d)" % (current_value, child_count))
					child_count = 0
			else:
				child_count = 0
			

			#update the last_statuses so we won't rely on the GUI
			last_contact = contact
			last_number = number
			last_status = status
			last_missed = missed

			#We want the contact to show as the number if it's not in the phonebook.
			if contact == "":
				contact = number
			
			#style status
			if status == 0:
				status = CallsTab.conf.get('phonelog','received_mark')
			elif status == 1:
				status = CallsTab.conf.get('phonelog','made_mark')
			elif status == 2:
				status = CallsTab.conf.get('phonelog','missed_mark')
				
			
			parent_added = model.append(parent, ( contact , 
					number ,
					timeToString(call_time) ,
					active_time, 
					visual_flag and (call_time > previous_time) ,
					status
					)
				)

			if parent == None:
				last_parent_added = parent_added
		#ugly hack for the last now showing counts bug
		if child_count > 1:
			child_count += 1
			#if set in config, add the '(count)' to the contact field
			if CallsTab.conf.getboolean('phonelog','show_group_count'):
				current_value = model[last_parent_added][self.CONTACT_POSITION]
				model.set_value(last_parent_added,self.CONTACT_POSITION, "%s (%d)" % (current_value, child_count))
				
		#Set last refresh time to now
		CallsTab.conf.set('viewlog',type,str(time.time()))
		return True										


	def callButton_clicked (self, button):
		global phone_data
		phoneObject = phone_data.getPhoneObject(systemBus)
		list = self.__list
		
		number = self.__getSelectedNumber()
		
		if number != None:
			#TODO, once the highlevel api work, change to them.
			phoneObject.Initiate (number, 'voice')
		
	def numberButton_clicked (self, button):
		list = self.__list

		get_column = self.__getContactColumn()

		contact_column = list.get_column(get_column)
		renderer = contact_column.get_cell_renderers()[0]

		
		if self.__contact_show_column == self.CONTACT_POSITION:
			self.__contact_show_column = self.NUMBER_POSITION
			button_label = "Names"

		else:
			self.__contact_show_column = self.CONTACT_POSITION
			button_label = "Numbers"
			
		button.set_label(button_label)
		contact_column.set_attributes(renderer, text=self.__contact_show_column)

		
		
	def durationButton_clicked (self, button):
		list = self.__list
		
		get_column = self.__getDateColumn()

		date_column = list.get_column(get_column)
		renderer = date_column.get_cell_renderers()[0]

		
		if self.__date_show_column == self.DATE_POSITION:
			self.__date_show_column = self.DURATION_POSITION
			button_label = "Date"

		else:
			self.__date_show_column = self.DATE_POSITION
			button_label = "Duration"
			
		button.set_label(button_label)
		date_column.set_attributes(renderer, text=self.__date_show_column)

		
		
	
	def __getSelectedNumber(self):
		list = self.__list
		selected = list.get_selection().get_selected_rows()
		selected = selected[1][0]

		row = list.get_model()[selected]

		number = row[self.NUMBER_POSITION]
		return number
	def addToTab(self, notebook):
		type = typeFromLegacyDaemonType(self.__type)
		if CallsTab.conf.get('phonelog',type + '_tab_type') == 'icon':
			tabWidget = gtk.Image()
			image_path = CallsTab.conf.get('phonelog',type + '_tab_image_file')

			#if not absolute
			if image_path[0] != '/':
				image_path = ICONS_PATH + image_path
				
			tabWidget.set_from_file(image_path)
		else:
			tabWidget = gtk.Label(CallsTab.conf.get('phonelog',type + '_tab_name') )
		notebook.insert_page(self.getTab(), tabWidget)
		notebook.set_tab_label_packing(self.getTab(), True, True, gtk.PACK_START)
class GeneralTab(CallsTab):
	#ACTUAL GUI POSTITON
	STATUS_COLUMN = 0	
	CONTACT_COLUMN = 1
	DATE_COLUMN = 2
	def __getStatusColumn(self):
		return self.STATUS_COLUMN
		
	def createList(self):
		CallsTab.createList(self)
		
		renderer = gtk.CellRendererText()
		renderer.set_property('weight', 800)
		renderer.set_property('size-points', 8)
		
		column0 = gtk.TreeViewColumn("Status", renderer, text=self.STATUS_POSITION)
		list = self.getList()
		list.insert_column( column0, self.__getStatusColumn() )
	def populateList(self, group_type = None):
		if group_type == None:
			group_type = 2
		CallsTab.populateList(self, 2)
	


class SignalMonitor:
	PHONE_BUSNAME = 'org.freesmartphone.ogsmd'
	PHONE_OBJECTPATH = '/org/freesmartphone/GSM/Device'
	PHONE_INTERFACE = 'org.freesmartphone.GSM.Call'
	__bus = None
		
	def __init__(self, bus):
		self.__bus = bus
		self.__connectCallStatus()

	def __connectCallStatus(self):
		bus = self.__bus
		proxy = bus.get_object(self.PHONE_BUSNAME,self.PHONE_OBJECTPATH)
		iface = dbus.Interface(proxy, self.PHONE_INTERFACE)
		iface.connect_to_signal("CallStatus", self.cb_CallStatus, self.__config)
        			
	def cb_CallStatus(self, id, status, props):
		#should this even happen?
		if props == None:
			return 

		
		#we only handle release
		if status != "release":
			return 

		"""
		direction = props[0]
		if direction == "incoming":
			incoming.populateList()
			missed.populateList()
		elif direction == "outgoing":
			outgoing.populateList()
		"""
		#on release update all, figure out how to check what to
		#update.
		#FIXME: possible race condition with the phonelog daemon.
		incoming.populateList()
		missed.populateList()
		outgoing.populateList()
		general.populateList()
		
class PhoneData:
	#OPHONEKITD related
	OPHONEKITD_DB = "/var/db/phonelog.db"
	CALL_STATUS_INCOMING = 0
	CALL_STATUS_OUTGOING = 1
	CALL_STATUS_ACTIVE = 2
	CALL_STATUS_HELD = 3
	CALL_STATUS_RELEASE = 4

	"""PHONELOG_BUSNAME = "org.freesmartphone.opimd"
	PHONELOG_OBJECTPATH = "/org/freesmartphone/PIM/Log"
	PHONELOG_INTERFACE = "org.freesmartphone.PIM.Log.Calls"
	"""
	
	PHONELOG_BUSNAME = "org.smartphone.opimd"
	PHONELOG_OBJECTPATH = "/org/smartphone/PIM/Log"
	PHONELOG_INTERFACE = "org.smartphone.PIM.Log.Calls"

	CONTACTS_BUSNAME = 'org.freesmartphone.ogsmd'
	CONTACTS_OBJECTPATH = '/org/freesmartphone/GSM/Device'
	CONTACTS_INTERFACE = 'org.freesmartphone.GSM.SIM'

	PHONE_BUSNAME = 'org.freesmartphone.ogsmd'
	PHONE_OBJECTPATH = '/org/freesmartphone/GSM/Device'
	PHONE_INTERFACE = 'org.freesmartphone.GSM.Call'

	LEGACY_TYPE = 0
	OPHONEKITD_TYPE = 1
	__phonelog_type = OPHONEKITD_TYPE
	__database = None
	__phoneLog = None
	__contacts = None
	conf       = None # is inited before use to ConfigParser object

	def __init__(self, systemBus, config):
                # init the ConfigParser object once, bail out if failing.
                if PhoneData.conf == None:
                  PhoneData.conf = config
                assert PhoneData.conf != None
		if PhoneData.conf.getboolean('phonelog','phonekitd'):
			if not os.path.exists(self.OPHONEKITD_DB):
				print "Can't Find " + self.OPHONEKITD_DB + " Falling back to the daemon"
				self.useLegacy(systemBus)
				PhoneData.conf.set('phonelog','phonekitd', 'false')
			self.useOphonekitd()	
		else:
			self.useLegacy(systemBus)
	def useLegacy(self, systemBus):
		self.__phonelog_type = self.LEGACY_TYPE
		self.__phoneLog = self.getPhoneLogObject(systemBus)
	def useOphonekitd(self):
		self.__phonelog_type = self.OPHONEKITD_TYPE
		self.__database = sqlite3.connect(self.OPHONEKITD_DB)
	def initContacts(self):
		contactsObject = self.getContactsObject(systemBus)
		self.__contacts = contactsObject.RetrievePhonebook("contacts")
	def getContact(self, number):
		contacts = self.__contacts
		if contacts == None:
			return ""
			
		for contact in contacts:
			if self.comparePhoneNumber(contact[2], number):
				return contact[1]
		return ""

	def comparePhoneNumber(self, number1, number2):
		'''
		Compares two phone numbers. They are considered equal if:
		a) One does not contain digits, and they are equal as strings
		or
		b) Both start with a "+", and all following digits are equal
		or
		c) At least one of them does not start with a "+", and the
		   last 7 digits are equal
		'''
		digits1 = filter (lambda c: c.isdigit() or c == '+', number1)
		digits2 = filter (lambda c: c.isdigit() or c == '+', number2)

		if digits1 == '' or digits2 == '':
			return number1 == number2
		if digits1[0] == digits2[0] == '+':
			return digits1 == digits2
		else:
			return digits1[-7:] == digits2[-7:]
	def getPhonekitCallsList(self, type):
		database = self.__database
		get_fields = "number, strftime('%s',startTime), direction, duration"
		#if type == "missed":
		#	calls = database.execute("SELECT %s FROM missed_calls WHERE direction = ? ORDER BY startTime DESC LIMIT ?" % (get_fields,  ) ,\
		#		(CALL_STATUS_INCOMING, config.get('missed_limit'))).fetchall()
		if type == "missed":
			calls = database.execute("SELECT %s FROM calls WHERE direction = ? AND activeTime IS NULL ORDER BY startTime DESC LIMIT ?" % (get_fields, ), \
			(self.CALL_STATUS_INCOMING, PhoneData.conf.getint('phonelog','missed_limit'))).fetchall()
		elif type == "incoming":
			calls = database.execute("SELECT %s FROM calls WHERE direction = ? AND activeTime IS NOT NULL ORDER BY startTime DESC LIMIT ?" % (get_fields, ), \
			(self.CALL_STATUS_INCOMING, PhoneData.conf.getint('phonelog','received_limit'))).fetchall()
		elif type == "outgoing":
			calls = database.execute("SELECT %s FROM calls WHERE direction = ? ORDER BY startTime DESC LIMIT ?" % (get_fields, ), \
				(self.CALL_STATUS_OUTGOING, PhoneData.conf.getint('phonelog','made_limit'))).fetchall()
		elif type == "all":
			calls = database.execute("SELECT %s FROM calls ORDER BY startTime DESC LIMIT ?" % (get_fields, ), \
				(PhoneData.conf.getint('phonelog','general_limit'),) ).fetchall()
		else:
			return None
		return calls
		

	def clean(self):
		if self.__database != None:
			self.__database.close()
	def getCalls(self, type):
		if PhoneData.conf.getboolean('phonelog','phonekitd'):
			calls = self.getPhonekitCallsList(type)
			if len(calls) == 0:
				return None				
		else:
			legacy_limit = typeFromLegacyDaemonType(type)
			calls = self.__phoneLog.GetCallsList(type, PhoneData.conf.get(legacy_limit + "_limit"))
			try: #hack because i send dbus empty
				calls[0]
			except:
				return None
		return calls
	def getDbusObject (self, bus, busname , objectpath , interface):
		dbusObject = bus.get_object(busname, objectpath)
		return dbus.Interface(dbusObject, dbus_interface=interface)
	def getPhoneLogObject (self, bus):
		return self.getDbusObject (bus,
				      self.PHONELOG_BUSNAME,
				      self.PHONELOG_OBJECTPATH,
				      self.PHONELOG_INTERFACE
				     )

	def getContactsObject (self, bus):
		return self.getDbusObject (bus,
				      self.CONTACTS_BUSNAME,
				      self.CONTACTS_OBJECTPATH,
				      self.CONTACTS_INTERFACE
				     )

	def getPhoneObject (self, bus):
		return self.getDbusObject (bus,
				      self.PHONE_BUSNAME,
				      self.PHONE_OBJECTPATH,
				      self.PHONE_INTERFACE
				     )

#LEGACY SUPPORT FUNCTIONS
def stringToTabNumber(string):
	if string.lower() == "received":
		return PAGE_INCOMING
	elif string.lower() == "made":
		return PAGE_OUTGOING
	elif string.lower() == "missed":
		return PAGE_MISSED
	elif string.lower() == "general":
		return PAGE_GENERAL
def typeFromLegacyDaemonType(type):
	if type == "incoming":
		return 'received'
	elif type == "outgoing":
		return 'made'
	elif type == "missed":
		return 'missed'
	elif type == "all":
		return 'general'
	else:
		return "received"
#END OF LEGACY FUNCTIONS

def timeToString(call_time):
	now = datetime.now().timetuple()
	time_tuple = call_time.timetuple()
	#check if it's today
	if (now[0] == time_tuple[0]) and \
	   (now[1] == time_tuple[1]) and \
	   (now[2] == time_tuple[2]):

		return "Today, " + call_time.strftime(config.get('phonelog','time_format'))
	else:
		return call_time.strftime(config.get('phonelog','date_format') + " " + config.get('phonelog','time_format') )

def quitMainloop(*dump):
	mainloop.quit()

#THIS GLOBAL VAR IS PART OF THIS FUNCTION
upright = None
def cb_win_resize(window, rect, notebook):
	global upright
	#update upright, and no need to go further if
	#we are already in the same position
	tmp_upright = (rect.height > rect.width)
	if tmp_upright == upright:
		return
	else:
		upright = tmp_upright
	
	if upright:
		if config.getboolean('phonelog','debug'):
			print "Upright"
		notebook.set_property("tab-pos", gtk.POS_TOP)
	else:
		if config.getboolean('phonelog','debug'):
			print "Rotated"
		notebook.set_property("tab-pos", gtk.POS_LEFT)

def init_last_view_times(config):
    if not config.has_section('viewlog'):
      config.add_section('viewlog')

    if not config.has_option('viewlog', 'incoming'):
      config.set('viewlog','incoming', '0')
    if not config.has_option('viewlog', 'outgoing'):
      config.set('viewlog','outgoing', '0')
    if not config.has_option('viewlog', 'missed'):
      config.set('viewlog','missed', '0')
    if not config.has_option('viewlog', 'all'):
      config.set('viewlog','all', '0')


#############################################
################# MAIN ######################
#############################################

print "Phonelog"
#create the config dir if doesn't exist.
if not os.path.exists(CONFIGURATION_DIR):
	os.mkdir(CONFIGURATION_DIR)

DBusGMainLoop(set_as_default=True)
mainloop = gobject.MainLoop()

systemBus = dbus.SystemBus()
config = ConfigParser.ConfigParser()
config.read([DEFAULT_CONFIG_PATH, CONFIGURATION_FILE])
init_last_view_times(config)
phone_data = PhoneData(systemBus, config)

#if we auto refresh is set
if config.getboolean('phonelog','auto_refresh'):
	RefreshMonitor = SignalMonitor(systemBus)


if config.getboolean('phonelog','debug'):
	print "Initialized global vars"
	print "Initializing gtk interface"

win = gtk.Window()
notebook= gtk.Notebook()
win.add (notebook)
win.connect('delete-event', quitMainloop )
win.set_title("Phone Log")
win.set_default_size(480,640)

if config.getboolean('phonelog','change_rotate_layout'):
	win.connect('size-allocate', cb_win_resize, notebook) #redsign on resize


incoming = CallsTab('incoming', conf=config)
outgoing = CallsTab('outgoing')
missed = CallsTab('missed', True)
general = GeneralTab('all')


incoming.addToTab(notebook)
outgoing.addToTab(notebook)
missed.addToTab(notebook)
general.addToTab(notebook)

if config.getboolean('phonelog','debug'):
	print "Showing main window"
win.show_all()

startup_page = stringToTabNumber(config.get('phonelog','startup_tab') )
notebook.set_current_page(startup_page)

#retrieve contacts
phone_data.initContacts()

incoming.populateList()
outgoing.populateList()
missed.populateList()
general.populateList()

#end of inits.
mainloop.run()

#clean and exit
phone_data.clean()
# write out config file on exit (also last viewed times)
with open(CONFIGURATION_FILE,'w+') as f:
  config.write(f)
